use crate::user::User;

pub mod user;

#[derive(Debug, Default, Clone)]
pub struct Issues {
    list: Vec<Issue>,
}

impl Issues {
    pub fn new() -> Self {
        let root_issue = Issue {
            name: "root".to_string(),
            status: Status::CloseAsCmp,
            log: Vec::new(),
            created_by: User::new("root", "root"),
            from: 0,
        };
        Self {
            list: vec![root_issue],
        }
    }

    pub fn add_new_issue(&mut self, i: Issue) -> usize {
        let l = self.list.len();
        self.list.push(i);
        l
    }

    pub fn get_list(&self) -> &Vec<Issue> {
        &self.list
    }

    pub fn find_from_title<T: AsRef<str>>(&mut self, s: T) -> Option<Vec<&mut Issue>> {
        let res = self
            .list
            .iter_mut()
            .filter(|f| f.name.contains(s.as_ref()))
            .collect::<Vec<_>>();
        if res.is_empty() { None } else { Some(res) }
    }

    pub fn get(&self, index: usize) -> Option<&Issue> {
        self.list.get(index)
    }

    pub fn get_mut(&mut self, index: usize) -> Option<&mut Issue> {
        self.list.get_mut(index)
    }

    pub fn fork(&mut self, from: usize) -> Option<usize> {
        let mut forked = self.get(from)?.clone();
        forked.from = from;
        self.get_mut(from).unwrap().status = Status::CloseAsForked;
        Some(self.add_new_issue(forked))
    }
}

#[derive(Debug, Clone)]
pub struct Issue {
    name: String,
    status: Status,
    log: Vec<Log>,
    created_by: User,
    from: usize,
}

impl Issue {
    pub fn new<T: AsRef<str>>(name: T, user: User) -> Self {
        Self {
            name: name.as_ref().to_string(),
            status: Status::default(),
            log: Vec::new(),
            created_by: user,
            from: 0,
        }
    }

    pub fn close_as_cmp(&mut self) {
        self.status = Status::CloseAsCmp;
    }

    pub fn close_as_not_planed(&mut self) {
        self.status = Status::CloseAsNotPlaned;
    }

    pub fn close_as_forked(&mut self) {
        self.status = Status::CloseAsForked;
    }

    pub fn log(&mut self, new_log: Log) {
        self.log.push(new_log);
    }
}

#[derive(Debug, Default, Clone)]
pub enum Status {
    #[default]
    Open,
    CloseAsCmp,
    CloseAsNotPlaned,
    CloseAsForked,
}

#[derive(Debug, Clone)]
pub struct Log {
    content: String,
    date: chrono::DateTime<chrono::Local>,
    user: user::User,
}

impl Log {
    pub fn new<T: AsRef<str>>(content: T, user: user::User) -> Self {
        Self {
            content: content.as_ref().to_string(),
            date: chrono::Local::now(),
            user,
        }
    }
}

pub fn add(x: i32, y: i32) -> i32 {
    x + y
}
